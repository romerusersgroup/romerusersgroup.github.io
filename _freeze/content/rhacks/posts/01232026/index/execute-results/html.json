{
  "hash": "3b61e97197d61c49ef381b6ab77fadb5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R-Hacks | Showing Top & Bottom values in one clear visualization\"\nsubtitle: \"\"\ndescription: \"R-Hacks\"\nauthor: \"Lucio Colonna\"\ndate: \"23 December 2026\"\nimages: \"images/image-1.png\"\nseries: R-Hacks\ncategories: \n  - data-wrangling\n  - functions\nlayout: single\ntoc-location: left\ntoc: true\ncode-overflow: wrap\nexecute: \n  warning: false\n  message: false\n---\n\n *This hack is based on my analysis on Kaggle analysis linked as follows (please see Chapter **4.3**):*  \nðŸ”— <https://www.kaggle.com/code/lcolon/exploring-2024-software-engineer-salaries>\n\n<br>\nWhen exploring a distribution, a very common question is:\n\n> Who are the top performers, and who are at the bottom?\n\nShowing only the Top values might hid some context, while showing two separate charts can make comparison harder.\n\nThis R-Hack shows a **simple** and **reusable pattern** to display Top and Bottom values together in a single, clean visualization, as the one showed below:\n\n<br>\n\n![](image1.png){width=\"80%\" fig-align=\"center\"}\n\n<br>\n\n---\n<br>\n\n## Step 0 â€“ Create an example dataset\n\nLetâ€™s start from a small, simulated dataset representing average salaries for different companies:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nset.seed(123)\n\ndf <- data.frame(\n  company = (LETTERS[1:26]),\n  avg_salary = round(runif(26, min = 60, max = 180), 0)\n)\n\nhead(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  company avg_salary\n1       A         95\n2       B        155\n3       C        109\n4       D        166\n5       E        173\n6       F         65\n```\n\n\n:::\n:::\n\n\n<br>\n\n## Step 1 â€“ Build Top & Bottom datasets in a single pipeline\n\nIn this step, we extract both the Top 10 and Bottom 10 values using a single, readable pipeline.\n\nThe idea is simple. Starting from the same dataset:\n\n- select the **Top 10** by applying ```slice_max()```, which returns all observations within the top 10 ranking positions, including any ties\n\n- select the **Bottom 10** by applying ```slice_min()```, returning all observations within the lowest 10 ranking positions, again including ties\n\n- assign a clear **group label** to each subset\n\n- combine the two subsets into a single dataframe for visualization and further analysis\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_df <- \n  bind_rows(\n    df %>% \n      slice_max(avg_salary, n = 10, with_ties = TRUE) %>%\n      mutate(group = \"Top 10\"),\n    \n    df %>% \n      slice_min(avg_salary, n = 10, with_ties = TRUE) %>%\n      mutate(group = \"Bottom 10\")\n  )\n\nhead(plot_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  company avg_salary  group\n1       X        179 Top 10\n2       K        175 Top 10\n3       T        175 Top 10\n4       E        173 Top 10\n5       P        168 Top 10\n6       H        167 Top 10\n```\n\n\n:::\n:::\n\n\n<br>\n\n## Step 2 -  Plot the data\nIn this step, starting from the dataframe created in the previous step, we build a simple visualization with ```ggplot```:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_base <- ggplot(plot_df, \n                    aes(x = reorder(company, -avg_salary), y = avg_salary)) +\n  geom_col(fill = \"steelblue\") +\n  geom_text(aes(label = avg_salary), vjust = -0.4, size = 4) +\n  facet_wrap(~ fct_rev(group), scales = \"free_x\") +\n  labs(\n    title = \"Top and Bottom Companies by Average Salary\",\n    subtitle = \"Simulated data example\\n\\n\",\n    y = \"Average yearly salary\",\n    x = NULL\n  ) +\n  theme_minimal() +\n  theme(\n    panel.grid = element_blank(),\n    axis.text.x = element_text(size = 10),\n    axis.text.y = element_blank()\n  )\n\nplot_base\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n<br>\n\n## Step 3 - Generate gradient color palettes\n\nNow that the base chart is working, we can make it more informative by adding two gradient color palettes:\n\n- one gradient for the Top group (blue shades)\n- one gradient for the Bottom group (red shades)\n\nInstead of assigning a single color per group, we assign a slightly different shade to **each bar**. This creates a clean gradient effect while keeping the plot readable â€” even when ties produce more than 10 observations per group.\n\nTo do this, we:\n\n- generate a group-specific palette with ```colorRampPalette()```, sized to the number of rows in each group (so it adapts if ties expand the selection)\n- group the data by ```group``` (Top vs Bottom)\n- assign colors row by row using ```row_number()```\n- store the result in a new column called ```color```\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_df <- plot_df %>%\n  group_by(group) %>%\n  mutate(\n    color = if_else(\n      group == \"Top 10\",\n      colorRampPalette(c(\"darkblue\", \"lightblue\"))(n())[row_number()],\n      colorRampPalette(c(\"darkred\", \"lightcoral\"))(n())[row_number()]\n    )\n  ) %>%\n  ungroup()\n\nhead(plot_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 Ã— 4\n  company avg_salary group  color  \n  <chr>        <dbl> <chr>  <chr>  \n1 X              179 Top 10 #00008B\n2 K              175 Top 10 #131895\n3 T              175 Top 10 #26309F\n4 E              173 Top 10 #3948A9\n5 P              168 Top 10 #4C60B3\n6 H              167 Top 10 #6078BD\n```\n\n\n:::\n:::\n\n\n<br>\n\n## Step 4 - Style the chart using the new colors\n\nAt this point, we donâ€™t want to rewrite the entire ggplot call.\nInstead, we:\n\n- reuse the base chart (```plot_base```)\n\n- replace its dataset with the updated ```plot_df``` (the one that now includes color) using the ```%+%``` operator\n\n- add a new ```geom_col()``` that maps fill to the color column\n\n- use ```scale_fill_identity()``` so ```ggplot``` uses the colors as they are listed in the ```color``` column\n  \n\n::: {.cell}\n\n```{.r .cell-code}\nplot_styled <- (plot_base %+% plot_df) +\n  geom_col(aes(fill = color)) +\n  scale_fill_identity()\n\nplot_styled\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n<br>\n\n## In short\n\n- Extract **Top 10** and **Bottom 10** values from the same dataset using ```slice_max()``` and ```slice_min()```, including ties\n\n- **Combine** the two subsets into a single dataframe for a compact overview of the distribution extremes\n\n- Build a **clean base plot** to validate structure and layout\n\n- Enhance the visualization by applying **gradient colors** to distinguish Top and Bottom groups\n\n<br>\n\n::: callout-tip\nIf you want to stay up to date with the latest events from the **Rome R Users Group**, click here:\n\nðŸ‘‰ <https://www.meetup.com/rome-r-users-group/>\n\nAnd if you are curious, the full Kaggle notebook used for this tip is available here:\n\nðŸ”— <https://www.kaggle.com/code/lcolon/exploring-2024-software-engineer-salaries>\n:::",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}