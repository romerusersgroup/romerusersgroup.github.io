{
  "hash": "e40dbaeb9d59f47dfea22a049a598b31",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Compare multiple dataframes before binding them together\"\nsubtitle: \"A lightweight R Hack to check structural compatibility across many dataframes\"\ndescription: \"R-Hacks N.3\"\nauthor: \"Lucio Colonna\"\ndate: \"13 December 2026\"\nimages: \"images/image-1.png\"\nseries: R-Hacks\ncategories: \n  - data-wrangling\n  - functions\nlayout: single\ntoc-location: left\ntoc: true\ncode-overflow: wrap\nexecute: \n  warning: false\n  message: false\n---\n\n## \n\n![Create your function](images/image-1.png){width=\"60%\" fig-align=\"center\"}\n\n\n*This hack is based on my Cyclistic analysis on Kaggle (see Chapter **6.3**):*  \nüîó <https://www.kaggle.com/code/lcolon/cyclistic-2023-google-da-capstone-project-r>\n\nWhen working with multiple datasets a common question is:\n\n> *Are these dataframes really compatible before I bind them together?*\n\nPeople who work with data typically rely on a mix of approaches to answer this:  \nmanual checks (`names()`, `glimpse()`), warnings raised by `bind_rows()`, or dedicated helpers such as `compare_df_cols()` from the **`janitor`** package ‚Äî which is a solid and widely used solution for comparing column structures.\n\nHowever, in practice, it is often useful to have a **single, lightweight helper** that provides a **compact and readable overview** across *many dataframes at once*, without additional dependencies or verbose output.\n\nThis R Hack introduces a small **custom helper function** designed with that goal in mind, that you can easily reuse and adapt to your own workflows.\n\nIt performs an **omnicomprehensive structural comparison** before merging, checking column **count**, column **names**, and column **classes** across all pairs of dataframes:\n\n::: {.cell}\n\n```{.r .cell-code}\n#   comparison   same_ncol same_names same_class\n#   <chr>        <lgl>     <lgl>      <lgl>     \n# 1 df_a vs df_b TRUE      TRUE       TRUE      \n# 2 df_a vs df_c TRUE      TRUE       FALSE     \n# 3 df_a vs df_d TRUE      FALSE      FALSE     \n# 4 df_b vs df_c TRUE      TRUE       FALSE     \n# 5 df_b vs df_d TRUE      FALSE      FALSE     \n# 6 df_c vs df_d TRUE      FALSE      FALSE     \n```\n:::\n\n\n\n\n---\n\n## Step 0 ‚Äì Create example dataframes to compare\n\nTo make the idea concrete, let‚Äôs create four small dataframes.\nSome of them match perfectly, others don‚Äôt:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_a <- data.frame(\n  id = 1:3,\n  value = c(10, 20, 30)\n)\n\ndf_b <- data.frame(\n  id = 4:6,\n  value = c(40, 50, 60)\n)\n\n# Same columns, but different class for `value`\ndf_c <- data.frame(\n  id = 7:9,\n  value = as.character(c(70, 80, 90))\n)\n\n# Different column name\ndf_d <- data.frame(\n  id = 10:12,\n  amount = c(100, 200, 300)\n)\n```\n:::\n\n\n## Step 1 ‚Äì Define the helper function to compare dataframes\n\nThe function below takes a vector of dataframe names (as character strings) and compares each unique pair only once.\nIt works in three simple steps:\n\n1. It loads the dataframes from the environment using their **names**\n\n2. It iterates over all unique dataframe combinations, ensuring that each pair is checked only once (for example, it compares ```df_a``` vs ```df_b```, but not ```df_b``` vs ```df_a)```)\n\n3. For each pair, it performs the following **structural checks** and stores the results in a tibble:\n   - whether the **number of columns** matches\n   - whether column **names** are identical\n   - whether column **classes** are the same\n\nThe function then binds all tibbles together into a single **summary table**, making it easy to spot structural mismatches before combining the data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\ncompare_dataframes <- function(df_names) {\n\n  # Get DF names\n  df_list <- lapply(df_names, get)\n\n  # Initialize an empty list\n  results <- list()\n\n  # Selection of DF pairs to be compared\n  for (i in seq_len(length(df_list) - 1)) {\n    for (j in (i + 1):length(df_list)) {\n\n      results[[length(results) + 1]] <- tibble(\n        comparison = paste(df_names[i], \"vs\", df_names[j]),\n\n        # check number of columns\n        same_ncol  = ncol(df_list[[i]]) == ncol(df_list[[j]]),\n\n        # check columns name\n        same_names = identical(names(df_list[[i]]), names(df_list[[j]])),\n\n        # check columns class\n        same_class = identical(\n          sapply(df_list[[i]], class),\n          sapply(df_list[[j]], class)\n        )\n      )\n    }\n  }\n\n  comparison_result <- bind_rows(results)\n  return(comparison_result)\n}\n```\n:::\n\n\n## Step 2 ‚Äì Apply the function\n\nProvide the dataframe names as a character vector and invoke the function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_names <- c(\"df_a\", \"df_b\", \"df_c\", \"df_d\")\n\ncomparison_result <- compare_dataframes(df_names)\n\ncomparison_result\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 √ó 4\n  comparison   same_ncol same_names same_class\n  <chr>        <lgl>     <lgl>      <lgl>     \n1 df_a vs df_b TRUE      TRUE       TRUE      \n2 df_a vs df_c TRUE      TRUE       FALSE     \n3 df_a vs df_d TRUE      FALSE      FALSE     \n4 df_b vs df_c TRUE      TRUE       FALSE     \n5 df_b vs df_d TRUE      FALSE      FALSE     \n6 df_c vs df_d TRUE      FALSE      FALSE     \n```\n\n\n:::\n:::\n\n\n## Step 3 ‚Äì Interpret the results\n\nThe output table makes structural mismatches immediately visible:\n\n```same_ncol``` ‚Üí different number of columns\n\n```same_names``` ‚Üí different column names\n\n```same_class``` ‚Üí same columns, but different data types\n\nIn the example provided:\n\n```df_a``` vs ```df_b``` ‚Üí all **TRUE** (safe to bind)\n\n```df_a``` vs ```df_c``` ‚Üí same_class = **FALSE**\n\n```df_a``` vs ```df_d``` ‚Üí same_names = **FALSE**\n\nThis helps you catch issues before they turn into silent bugs.\n\n## In short\n\n- There is no single ‚Äúofficial‚Äù way to compare many dataframes at once\n\n- Helpers like ```compare_df_cols()``` from ```{janitor}``` are excellent for column-level inspection\n\n- This custom helper function provides a clear, compact overview before stacking or merging data\n\n- Think of it as a pre-flight checklist before combining your data\n\n<br>\n\n::: callout-tip\nIf you want to stay up to date with the latest events from the **Rome R Users Group**, click here:\n\nüëâ <https://www.meetup.com/rome-r-users-group/>\n\nAnd if you are curious, the full Kaggle notebook used for this tip is available here:\n\nüîó <https://www.kaggle.com/code/lcolon/cyclistic-2023-google-da-capstone-project-r>\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}